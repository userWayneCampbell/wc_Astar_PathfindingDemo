<!--
Programming Project 1: Pathding A*
Author: Wayne Campbell
School: Ohio Northern University
A* Star using Binary Heap. Heaps allow me to keep the open items in a sorted
order so I can just grab from top when I need the results.

References include:
 Binary Heap (with modifications) from Marijn Haverbeke http://eloquentjavascript.net/appendix2.html

-->
<script>
  var INIT = 0;
  var OPENED = 1;
  var CLOSED = 2;
  var VISITED = 3;
  var REALPATH = 4;

  var SEARCH_TYPE_BFS = 0;
  var SEARCH_TYPE_DFS = 1;
  var SEARCH_TYPE_UCS = 2;
  var SEARCH_TYPE_ASTAR = 3;

  var heuristicType;
  var Graph;
  var GraphSearch;
  var binaryHeap;
  var heapPointer = 0;
  var start;
  var goal;
  var width;
  var height;

  var keepNodes;
  var keepTime;

  var toggleStartGoal = false;

  var startTime;
  var endTime;

  /* begin timing */
  function wc_startTiming() {
    startTime = new Date();
  }

  /* stop timing */
  function wc_endTiming() {
    endTime = new Date();
  }

  /*				DISPLAY FUNCTIONS
  wc_createGraph(): 				Create Graph from form to the left. Check correct user Data
  wc_markGoalStart(): 		Mark the Goal and Start position
  wc_randomStartGoal():	When user clicks button, this happens




  */
  function wc_createGraph() {
    var html = "<table cellpadding=0 cellspacing=0 style=\"width: " + width * 16 + "px;\">";
    var cl;

    //Format: <td onclick="wc_markGoalStart(y,x);" class="character from imput" id="x(var x)y(var y)">&nbsp;</td>
    for (var y = 0; y < height; y++) {
      html += "<tr>";
      for (var x = 0; x < width; x++) {
        //change imput into readable outputs
        if (Graph[x][y] == "F") cl = "fo";
        else if (Graph[x][y] == "r") cl = "ri";
        //Check for correct imput
        else if (Graph[x][y] != "R" && Graph[x][y] != "f" && Graph[x][y] != "h" && Graph[x][y] != "M" && Graph[x][y] != "W") {
          alert("Invalid terrain feature [" + Graph[x][y] + "] in Graph data at position " + x + "," + y + " (which appears on line " + (y + 4) + ").  Valid Graph features are R, f, F, h, r, M, and W.");
          return;
        } else cl = Graph[x][y];
        if (x == start[0] && y == start[1]) cl = "man" + cl;
        else if (x == goal[0] && y == goal[1]) cl = "goal" + cl;
        else if (GraphSearch && (GraphSearch[x][y].state == REALPATH)) cl = "fade" + cl;
        else if (GraphSearch && (GraphSearch[x][y].state == VISITED || GraphSearch[x][y].state == CLOSED)) cl = "visited" + cl;

        //set html string with new table
        html += "<td onclick=\"wc_markGoalStart(" + x + "," + y + ");\" class=\"" + cl + "\" id = \"x" + x + "y" + y + "\">&nbsp;</td>";
      }
      html += "</tr>";
    }
    html += "</table>"
    var elem = document.getElementById("grid");
    elem.innerHTML = html;

  }

  function wc_markGoalStart(x, y) {
    if (!(x >= 0 && x <= (width - 1) && y >= 0 && y <= (height - 1))) {
      return;
    }
    if (toggleStartGoal) {
      goal[0] = x;
      goal[1] = y;
    } else {
      start[0] = x;
      start[1] = y;
    }
  }

  //This is a button click :^)
  function wc_randomStartGoal() {
    startX = Math.floor(Math.random() * width);
    startY = Math.floor(Math.random() * height);
    goalX = Math.floor(Math.random() * width);
    goalY = Math.floor(Math.random() * height);
    start[0] = startX;
    start[1] = startY;
    goal[0] = goalX;
    goal[1] = goalY;
    wc_resetMarkings();
    wc_createGraph()
  }

  //Display Faded Version of image
  function wc_setFade(idFaded) {
    var elem = document.getElementById(idFaded);
    if (!elem) return;
    if (elem.className.substring(0, 4) == "fade") elem.className = elem.className.substring(4);
    else elem.className = "fade" + elem.className;
  }

  //If visited, display visited image
  function wc_setVisit(idVisited) {
    var elem = document.getElementById(idVisited);
    if (!elem) return;
    if (elem.className.substring(0, 7) == "visited") elem.className = elem.className.substring(7);
    else elem.className = "visited" + elem.className;

  }

  //Reset all markings
  function wc_resetMarkings() {
    GraphSearch = null;
  }

  //Stupid Humans
  function wc_loadGraph() {
    wc_resetMarkings();
    var input = document.forms[0].elements["Graph"].value.split("\n");

    width = input[0].split(" ")[0];
    height = input[0].split(" ")[1];

    start = new Array(2);
    start[0] = input[1].split(" ")[0];
    start[1] = input[1].split(" ")[1];

    goal = new Array(2);
    goal[0] = input[2].split(" ")[0];
    goal[1] = input[2].split(" ")[1];

    Graph = new Array();
    for (var x = 0; x < width; x++) {
      Graph[x] = new Array(height);
      for (var y = 0; y < height; y++) {
        Graph[x][y] = input[3 + y].substring(x, Number(x) + 1);
      }
    }

    wc_createGraph();
  }

  //Array of first Graph to show up
  var Graphs = new Array();
  Graphs[0] =
    "15 20\n" +
    "12 0\n" +
    "7 18\n" +
    "MMMhhffffffffff\n" +
    "MMMMMhhffffffff\n" +
    "hMMMhhhffFFFfff\n" +
    "fhMhffFFFFFFFff\n" +
    "fhhhffFFFFFFFFF\n" +
    "ffffFFFFFFFFfff\n" +
    "rrrrfFFFFFFffff\n" +
    "fffrrffFFFfffff\n" +
    "RRffrrrfFFFFfff\n" +
    "fRffffrFFFFFFff\n" +
    "fRfffWWWWWFFFFF\n" +
    "fRffWWWWWWWWFFF\n" +
    "fRRfffWWWWWWWrr\n" +
    "ffRRRRffffWWfff\n" +
    "fffffRRRfffffff\n" +
    "fffffffRfffffff\n" +
    "hffffffRRRRRRRR\n" +
    "Mhhffffffffffff\n" +
    "Mhhffffffffffff\n" +
    "MMhhhffffffffff\n";

	Graphs[1]	= "30 20\n" +
	"15 5\n" +
	"15 15\n" +
	"MMMMMMMMMhhfffffffffffFFFMMMMM\n" +
	"MMMMMMMMhhffffffffffffffFFFMMM\n" +
	"hMMMMhhffFFFfffffffffffffFFFFF\n" +
	"fhMhffFFFFFFFfffffffffffffFFFF\n" +
	"fhhhffFFFFFFFFfffffffWWWWWFFFF\n" +
	"ffffFFFFFFFFffffffffWWWWffffff\n" +
	"rrrrrFFFFFFffffffffWWWWfffffff\n" +
	"hhffrffFFFfffWWWWWWWWWWWffffff\n" +
	"RRRRrrWWWWWWWWWWWWWWWWffffffff\n" +
	"hhhRfWWWWWWWWWWWWWWWrrrrrfffff\n" +
	"MMMRhWWWWWWWWWWfffffffffrrrfff\n" +
	"RRRRWWWWWWWWFFFfffffffffffrrrr\n" +
	"hhffffWWWWWWWFFfffffffffffffFF\n" +
	"ffffffffffWWfffffffffffffffFFF\n" +
	"fffffffffffffffffffffffFFFFFFF\n" +
	"fffffffffffffffffffFFFFFFFFFFF\n" +
	"hffffffffffffffffffFFFFFFFFFFF\n" +
	"MhhfffffffffffffFFFFFFFFFFFfff\n" +
	"MhhffffffffffffffFFFFFFFFFFFff\n" +
	"MMhhhfffffffffffffFFFFFFFFFFFf\n";


  /* load and render the preset Graph indicated by num */
  function wc_loadArrayGraph(num) {
    clearAllOldResults();
    document.forms[0].elements["Graph"].value = Graphs[num];
    wc_loadGraph();
  }

  /*
	Actualy algorithm: Pseudocode:

   */
  function wc_AStarSearch() {
    wc_startTiming();
    wc_resetMarkings();

    //2D Array to store: (expanded/visited/closed)
    //This array will also store all values of found items [x,y]
    GraphSearch = new Array();
    for (var x = 0; x < width; x++) GraphSearch[x] = new Array();

    for (var x = 0; x < width; x++)
      for (var y = 0; y < height; y++) {
        GraphSearch[x][y] = {
          "x": x,
          "y": y,
          "feature": Graph[x][y],
          "state": INIT,
          "path": new Array(),
          "cost": 0,
          "parent": null,
          "depth": 0,
          "bestCost": null
        }
      }

    var queue = new Array();
    heapClear();

    var pX = Number(start[0]);
    var pY = Number(start[1]);

    var bestCost = 99999999999;

    var deepest = 0;

    heuristicType = document.forms[0].elements["heur"][document.forms[0].elements["heur"].selectedIndex].value;

    GraphSearch[pX][pY].visited = new Array();
    v = "" + pX + "," + pY;
    GraphSearch[pX][pY].visited[v] = true;

    heapAdd(GraphSearch[pX][pY])

    var node;
    var steps = 0;
    var found = false;
    var skipped = 0;

    while ((heapPointer > 0) || (queue.length > 0)) {
      node = heapDelete();

			//Replece with real cost
      if (node.parent) {
				//condition ? value of true : value of false) + (cost of position with heauristic)
        node.cost = Number(node.parent ? node.parent.cost : 0) + cost(node.x, node.y, false);
      }

      // if bestCost = null, set as current. If bestcost = > current node cost, set as bestCost;
      if (GraphSearch[node.x][node.y].bestCost == null) GraphSearch[node.x][node.y].bestCost = node.cost;
      else if (node.cost < GraphSearch[node.x][node.y].bestCost) {
        GraphSearch[node.x][node.y].bestCost = node.cost;
      } //else skip it
      else {
        skipped++;
        continue;
      } // otherwise, ignore this node, since we already saw a node of better cost
      steps++; //step into next step
      if (node.depth > deepest) {
        deepest = node.depth;
      }

      //Found Goal
      if (node.x == goal[0] && node.y == goal[1]) {
        if (node.cost < bestCost) {
          bestNode = node;
          bestCost = node.cost;
        }
        found = true;
        break;
      }

      //Didn't find goal
      /* try to expand all the possible child nodes from here. */
      pushValidNode(queue, GraphSearch, node, node.x - 1, node.y); // left
      pushValidNode(queue, GraphSearch, node, node.x + 1, node.y); // right
      pushValidNode(queue, GraphSearch, node, node.x, node.y - 1); // up
      pushValidNode(queue, GraphSearch, node, node.x, node.y + 1); // down

      //Search Diagonals if selected
      if (document.forms[0].elements["allowDiagonal"].checked) {
        pushValidNode(queue, GraphSearch, node, node.x - 1, node.y - 1);
        pushValidNode(queue, GraphSearch, node, node.x + 1, node.y - 1);
        pushValidNode(queue, GraphSearch, node, node.x - 1, node.y + 1);
        pushValidNode(queue, GraphSearch, node, node.x + 1, node.y + 1);
      }
			//Mark visited
			if (document.forms[0].elements["trackVisited"].checked) {
      	GraphSearch[node.x][node.y].state = CLOSED;
		  }

      node.path = null;

    }
    wc_endTiming();
    if (!found) {
      alert("Sorry, goal cannot be reached.");
      return;
    }
    displayAllNodeResults(steps, skipped, node, GraphSearch, deepest);

  }

  /* if the given node is valid, and has not already been visited along the current path, then push it onto the search queue. */
  function pushValidNode(queue, GraphSearch, parent, x, y) {
    //Don't push array out of bounds, don't use water (W)
    if (x >= 0 && x < width && y >= 0 && y < height && GraphSearch[x][y].feature != "W") {
      //Already visited?
      if (!isVisited(parent, x, y)) {
        var item = {
          "x": x,
          "y": y,
          "state": OPENED,
          "cost": parent.cost + cost(x, y),
          "parent": parent,
          "depth": parent.depth + 1
        };
        heapAdd(item);
      }
    }
  }

  //Is this node already visited from parent to that x,y position?
  function isVisited(parent, x, y) {
    while (parent != null) {
      if (parent.x == x && parent.y == y) {
        return true;
      }
      parent = parent.parent;
    }
  }

  /* display all the search results on the Graph and in the results area of the page. */
  function displayAllNodeResults(steps, skipped, node, GraphSearch, deepest) {
    var p = "";

    var parent = node;
    var count = 0;
    while (parent != null) {
      p = parent.x + "," + parent.y + " " + p;
      if ((parent.x != goal[0] || parent.y != goal[1]) && (parent.x != start[0] || parent.y != start[1])) {
        GraphSearch[parent.x][parent.y].state = REALPATH;
      }
      parent = parent.parent;
      count++;
    }

    wc_createGraph();
    clearAllOldResults();

    var visitCount = 1;
    for (var i = 0; i < width; i++)
      for (var j = 0; j < height; j++)
        if (GraphSearch[i][j].state == REALPATH || GraphSearch[i][j].state == VISITED || GraphSearch[i][j].state == CLOSED)
          visitCount++;

    results("A* STAR" + " Visited <b>" + steps + "</b> nodes. Skipped <b>" + skipped + "</b> nodes.<br>");
    results("Explored <b>" + visitCount + "</b> grid squares (<b>" + (height * width - visitCount) + "</b> unexplored).<br>");
    results("Path: <b>" + (count) + "</b> grid squares.<br>");
    results("Cost: <b>" + (node.cost) + "</b>.<br>");
    results("The deepest node visited had depth <b>" + deepest + "</b>.<br>");
    results("The search took <b>" + ((endTime.getTime() - startTime.getTime()) / 1000) + "</b> seconds.<br>")
    results("path: " + p + "<br>");

    keepNodes = steps;
    keepTime = ((endTime.getTime() - startTime.getTime()) / 1000);
  }

  //return the actual cost of the aSTAR terrain cost
  function cost(x, y, astar) {
    if (x < 0 || x > width - 1 || y < 0 || y > height - 1) {
      return 0
    };
    var c;
    var node = GraphSearch[x][y];

    var gx = Number(goal[0]);
    var gy = Number(goal[1]);
    switch (node.feature) {
      case "R":
        c = 1;
        break;
      case "f":
        c = 2;
        break;
      case "F":
        c = 4;
        break;
      case "h":
        c = 5;
        break;
      case "r":
        c = 7;
        break;
      case "M":
        c = 10;
        break;
      default:
        c = 999999;
    }
    //HEURISTIC
    if (heuristicType == 0)
    //manhattan distance
      c += Math.abs(gx - x) + Math.abs(gy - y);
    else if (heuristicType == 1)
    // euclidian distnace (straight line)
      c += Math.sqrt((gx - x) * (gx - x) + (gy - y) * (gy - y));

    return c;
  }

  //Total Number of nodes visited
  function countVisited(GraphSearch) {
    var count = 0;
    for (i = 0; i < GraphSearch.length; i++)
      for (j = 0; j < GraphSearch[i].length; j++)
        if (GraphSearch[i][j].state == VISITED || GraphSearch[i][j].state == CLOSED) count++;

    return Math.round(count / (height * width) * 100);
  }

  /* write the results to the screen */
  function results(msg) {
    document.getElementById("results").innerHTML += msg;
  }

  function clearAllOldResults() {
    document.getElementById("results").innerHTML = "";
  }

  //Add to Heap
  function heapAdd(item) {
    if (!binaryHeap || binaryHeap.length == 0) {
      binaryHeap = new Array();
      binaryHeap[0] = item;
      heapPointer++;
      return;
    }
    binaryHeap[heapPointer] = item;
    var i = heapPointer;
    var parent;
    while (i != 0) {
      parent = Math.floor((i - 1) / 2);
      if (binaryHeap[parent].cost > binaryHeap[i].cost) {
        heapSwap(parent, i);
      }
      i = parent;
    }
    heapPointer++;
  }

  //Clear Heap
  //http://eloquentjavascript.net/1st_edition/appendix2.html
  function heapDelete() {
    if (!binaryHeap) return false;
    if (binaryHeap[0] == null) return false;
    var item = binaryHeap[0];
    heapPointer--;
    binaryHeap[0] = binaryHeap[heapPointer];
    binaryHeap[heapPointer] = null;

    i = 0;
    while (binaryHeap[2 * i + 1]) {
      left = binaryHeap[2 * i + 1];
      right = binaryHeap[2 * i + 2];
      if (!right) {
        if (left.cost < binaryHeap[i].cost) {
          heapSwap(2 * i + 1, i);
          i = 2 * i + 1;
        } else break;
      } else {
        if (left.cost < right.cost && left.cost < binaryHeap[i].cost) {
          heapSwap(2 * i + 1, i);
          i = 2 * i + 1;
        } else if (left.cost >= right.cost && right.cost < binaryHeap[i].cost) {
          heapSwap(2 * i + 2, i);
          i = 2 * i + 2;
        } else break;
      }

    }
    return item;
  }

  function heapSwap(i, j) {
    swap = binaryHeap[i];
    binaryHeap[i] = binaryHeap[j];
    binaryHeap[j] = swap;
  }

  function heapClear() {
    binaryHeap = null;
    heapPointer = 0;

  }
</script>


<html>
<style>
  * {
    font-family: arial, verdana;
    font-size: 10pt;
  }

  textarea {
    font-family: courier;
    font-size: 8pt;
  }

  .table,
  .table td,
  .table th {
    border: thin solid black;
    border-collapse: collapse;
    padding: 2px 2px 2px 2px;
  }

  .M {
    width: 16px;
    height: 16px;
    background-image: url(M.gif);
  }

  .R {
    width: 16px;
    height: 16px;
    background-image: url(R.gif);
  }

  .f {
    width: 16px;
    height: 16px;
    background-image: url(f.gif);
  }

  .fo {
    width: 16px;
    height: 16px;
    background-image: url(fo.gif);
  }

  .h {
    width: 16px;
    height: 16px;
    background-image: url(h.gif);
  }

  .W {
    width: 16px;
    height: 16px;
    background-image: url(W.gif);
  }

  .ri {
    width: 16px;
    height: 16px;
    background-image: url(ri.gif);
  }

  .bard {
    border-collapse: collapse;
  }

  .board td {
    border-width: 0px;
  }

  .manM {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .manR {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .manf {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .manfo {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .manh {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .manW {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .manri {
    width: 16px;
    height: 16px;
    background-image: url(man.gif);
  }

  .fadeM {
    width: 16px;
    height: 16px;
    background-image: url(Mfade.gif);
  }

  .fadeR {
    width: 16px;
    height: 16px;
    background-image: url(Rfade.gif);
  }

  .fadef {
    width: 16px;
    height: 16px;
    background-image: url(ffade.gif);
  }

  .fadefo {
    width: 16px;
    height: 16px;
    background-image: url(fofade.gif);
  }

  .fadeh {
    width: 16px;
    height: 16px;
    background-image: url(hfade.gif);
  }

  .fadeW {
    width: 16px;
    height: 16px;
    background-image: url(Wfade.gif);
  }

  .faderi {
    width: 16px;
    height: 16px;
    background-image: url(rifade.gif);
  }

  .goalM {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .goalR {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .goalf {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .goalfo {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .goalh {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .goalW {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .goalri {
    width: 16px;
    height: 16px;
    background-image: url(goal.gif);
  }

  .visitedM {
    width: 16px;
    height: 16px;
    background-image: url(Mvisited.gif);
  }

  .visitedR {
    width: 16px;
    height: 16px;
    background-image: url(Rvisited.gif);
  }

  .visitedf {
    width: 16px;
    height: 16px;
    background-image: url(fvisited.gif);
  }

  .visitedfo {
    width: 16px;
    height: 16px;
    background-image: url(fovisited.gif);
  }

  .visitedh {
    width: 16px;
    height: 16px;
    background-image: url(hvisited.gif);
  }

  .visitedW {
    width: 16px;
    height: 16px;
    background-image: url(Wvisited.gif);
  }

  .visitedri {
    width: 16px;
    height: 16px;
    background-image: url(rivisited.gif);
  }

  .Graphs {
    background-color: #ccffcc;
    padding: 2px 7px 2px 2px;
  }
</style>

<body onkeypress="return keypress(event)" onload="wc_loadArrayGraph(0)">
  <h1>Programming Project 1: A* Pathfinding - Wayne Campbell, Bryce Gray</h1>
  <p>
    <form>
      <table border="0">
        <tr valign="top">
          <td align="right" nowrap="true" class="Graphs">
            Create Your own Graph:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <br>
            <textarea cols="20" rows="20" name="Graph" id="Graph"></textarea>
            <br>
						<p>
							<a href="javascript:wc_loadArrayGraph(0)">Create Graph #1</a>
							<br>
						</p>
						<p>
							<a href="javascript:wc_loadArrayGraph(1)">Create Graph #2</a>
							<br>
						</p>
            <p>
              <a href="javascript:wc_loadGraph()">Create Graph from Above Data</a>
              <br>
            </p>

            <p>R = Road. Cost = 1</p>
            <p>f = field. Cost = 2</p>
            <p>F = Forest. Cost = 4</p>
            <p>h = Hill. Cost = 5</p>
            <p>r = river. Cost = 7</p>
            <p>M = Mountain. Cost = 10</p>
            <p>W = Deep Water.Cant Enter</p>
          </td>
          <td>
            <div id="grid">
            </div>
            <a href="javascript:wc_randomStartGoal();">Random Start/Goal</a>&nbsp;
            <br>
            <br>
            <input type="checkbox" name="allowDiagonal"> Use Diagonal.
            <br>
						<input type="checkbox" name="trackVisited"> Track Visited.
						<br>
            <a href="javascript:wc_AStarSearch();">A* wc_AStarSearch</a>, using the
            <select name="heur">
              <option value="0">Manhattan distance</option>
              <option value="1">Euclidian distance</option>
            </select> heuristic.
            <br>
            <div id="results"></div>
          </td>
        </tr>
      </table>
    </form>
  </p>

  </table>
  <div id="debug"></div>
</body>

</html>
